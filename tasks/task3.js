async function task3() {

console.log("task3");

const canvas = document.createElement("canvas");
canvas.style.position = "absolute";
canvas.style.top = "0";
canvas.style.left = "0";
document.body.appendChild(canvas);

const map = await LOADER.loadMap();

const centerLon = 16.36858;
const centerLat = 48.22351;

{
    const images = map.images;
    const json = JSON.parse(`{
        "name": "Vienna",
        "latitude": { "min": 48.088439, "max": 48.3582339 },
        "longitude": { "min": 16.1655603, "max": 16.5705245 },
        "height": { "min": 135.4, "max": 642.9 },
        "zoom": 9.379067342411403,
        "images": {
            "height": "vienna-height.png",
            "outdoors": "vienna-outdoors.png",
            "satellite": "vienna-satellite.png",
            "streets": "vienna-streets.png"
        },
        "comment": "Images generated by Cities: Skylines online heightmap generator (https://cs.heightmap.skydark.pl) (https://github.com/sysoppl/Cities-Skylines-heightmap-generator)"
    }`);
    Object.assign(map, json);
    map.images = images;
}

const image = map.images.satellite;

// Make canvas same size as image
canvas.width = image.width;
canvas.height = image.height;

const ctx = canvas.getContext("2d");

// Draw image on canvas
ctx.drawImage(image, 0, 0);

const latMin = map.latitude.min;
const latMax = map.latitude.max;
const lonMin = map.longitude.min;
const lonMax = map.longitude.max;

const treeLat = 48.18581927846211;
const treeLon = 16.42167996037569;

const treeX = (treeLon - lonMin) / (lonMax - lonMin) * image.width;
const treeY = (1 - (treeLat - latMin) / (latMax - latMin)) * image.height;

const centerX = (centerLon - lonMin) / (lonMax - lonMin) * image.width;
const centerY = (centerLat - latMin) / (latMax - latMin) * image.height;

// Draw tree
ctx.fillStyle = "red";
ctx.beginPath();
ctx.arc(treeX, treeY, 10, 0, 2 * Math.PI);
ctx.fill();
console.log(treeX, treeY);

// Draw center
ctx.fillStyle = "blue";
ctx.beginPath();
ctx.arc(image.width / 2, image.height / 2, 10, 0, 2 * Math.PI);
ctx.fill();
console.log(image.width / 2, image.height / 2);

// Draw lat,lon center
ctx.fillStyle = "00ff00";
ctx.beginPath();
ctx.arc(centerX, centerY, 10, 0, 2 * Math.PI);
ctx.fill();
console.log(centerX, centerY);

// Draw more green circles, increasing longitude until lonMax is reached
for (let lon = centerLon, lat = centerLat; lon <= lonMax && lat <= latMax; lon += 0.01, lat += 0.01) {
    const x = (lon - lonMin) / (lonMax - lonMin) * image.width;
    const y = (lat - latMin) / (latMax - latMin) * image.height;

    // Get x and y with spherical mapping (slerp) rather than linear
    /*const merc = new SphericalMercator({
        size: 256,
        antimeridian: false
    });
    const [x, y] = merc.px([lon, lat], 9);*/

    // Get x and y from Wikipedia (https://en.wikipedia.org/wiki/Web_Mercator_projection)
    //const leftSide = Math.pow(2, map.zoom) / 2 / Math.PI;
    //const x = Math.floor(leftSide * (lon + Math.PI));
    //const y = Math.floor(leftSide * (Math.PI - Math.log(Math.tan(Math.PI / 4 + lat / 2))));

    ctx.fillStyle = "#00ff00";
    ctx.beginPath();
    ctx.arc(x, y, 10, 0, 2 * Math.PI);
    ctx.fill();
    console.log("line", lon, lat, x, y);
}

// The above method is imprecise, so now use the Web Mercator projection
const treeX_webMercator = (treeLon + 180) / 360 * 256 * Math.pow(2, 9);
const treeY_webMercator = (1 - Math.log(Math.tan(treeLat * Math.PI / 180) + 1 / Math.cos(treeLat * Math.PI / 180)) / Math.PI) / 2 * 256 * Math.pow(2, 9);

// Now convert from Web Mercator to image coordinates (in range image.width ; image.height)
const treeX_image = (treeX_webMercator + 256 * Math.pow(2, 9)) / (256 * Math.pow(2, 9)) * image.width;
const treeY_image = (treeY_webMercator + 256 * Math.pow(2, 9)) / (256 * Math.pow(2, 9)) * image.height;

// Draw it in yellow
ctx.fillStyle = "yellow";
ctx.beginPath();
ctx.arc(treeX_image, treeY_image, 10, 0, 2 * Math.PI);
ctx.fill();
console.log(treeX_image, treeY_image);

}