// This file was compiled and minified from the following sources:
// - https://github.com/greggman/webgpu-utils/blob/dev/src/generate-mipmap.ts
// - https://github.com/greggman/webgpu-utils/blob/dev/src/typed-arrays.ts
(()=>{"use strict";var e={d:(r,n)=>{for(var t in n)e.o(n,t)&&!e.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:n[t]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{generateMipmap:()=>u,isTypedArray:()=>n,normalizeGPUExtent3D:()=>t,numMipLevels:()=>a});const n=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength;function t(e){return Array.isArray(e)||n(e)?[...e,1,1].slice(0,3):function(e){return[e.width,e.height||1,e.depthOrArrayLayers||1]}(e)}function a(e,r){const n=t(e),a=Math.max(...n.slice(0,"3d"===r?3:2));return 1+Math.log2(a)|0}const o=new WeakMap;function u(e,r,n){let t=o.get(e);t||(t={pipelineByFormatAndView:{},moduleByViewType:{}},o.set(e,t));let{sampler:a,uniformBuffer:u,uniformValues:i}=t;const{pipelineByFormatAndView:s,moduleByViewType:f}=t;n=n||function(e){switch(e.dimension){case"1d":return"1d";case"3d":return"3d";default:return e.depthOrArrayLayers>1?"2d-array":"2d"}}(r);let l=f[n];if(!l){const r=function(e){let r,n;switch(e){case"2d":r="texture_2d<f32>",n="textureSample(ourTexture, ourSampler, fsInput.texcoord)";break;case"2d-array":r="texture_2d_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              fsInput.texcoord,\n              uni.layer)";break;case"cube":r="texture_cube<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1))";break;case"cube-array":r="texture_cube_array<f32>",n="\n          textureSample(\n              ourTexture,\n              ourSampler,\n              faceMat[uni.layer] * vec3f(fract(fsInput.texcoord), 1), uni.layer)";break;default:throw new Error(`unsupported view: ${e}`)}return`\n        const faceMat = array(\n          mat3x3f( 0,  0,  -2,  0, -2,   0,  1,  1,   1),   // pos-x\n          mat3x3f( 0,  0,   2,  0, -2,   0, -1,  1,  -1),   // neg-x\n          mat3x3f( 2,  0,   0,  0,  0,   2, -1,  1,  -1),   // pos-y\n          mat3x3f( 2,  0,   0,  0,  0,  -2, -1, -1,   1),   // neg-y\n          mat3x3f( 2,  0,   0,  0, -2,   0, -1,  1,   1),   // pos-z\n          mat3x3f(-2,  0,   0,  0, -2,   0,  1,  1,  -1));  // neg-z\n\n        struct VSOutput {\n          @builtin(position) position: vec4f,\n          @location(0) texcoord: vec2f,\n        };\n\n        @vertex fn vs(\n          @builtin(vertex_index) vertexIndex : u32\n        ) -> VSOutput {\n          var pos = array<vec2f, 3>(\n            vec2f(-1.0, -1.0),\n            vec2f(-1.0,  3.0),\n            vec2f( 3.0, -1.0),\n          );\n\n          var vsOutput: VSOutput;\n          let xy = pos[vertexIndex];\n          vsOutput.position = vec4f(xy, 0.0, 1.0);\n          vsOutput.texcoord = xy * vec2f(0.5, -0.5) + vec2f(0.5);\n          return vsOutput;\n        }\n\n        struct Uniforms {\n          layer: u32,\n        };\n\n        @group(0) @binding(0) var ourSampler: sampler;\n        @group(0) @binding(1) var ourTexture: ${r};\n        @group(0) @binding(2) var<uniform> uni: Uniforms;\n\n        @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n          _ = uni.layer; // make sure this is used so all pipelines have the same bindings\n          return ${n};\n        }\n      `}(n);l=e.createShaderModule({label:`mip level generation for ${n}`,code:r}),f[n]=l}a||(a=e.createSampler({minFilter:"linear",magFilter:"linear"}),u=e.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i=new Uint32Array(1),Object.assign(t,{sampler:a,uniformBuffer:u,uniformValues:i}));const c=`${r.format}.${n}`;s[c]||(s[c]=e.createRenderPipeline({label:`mip level generator pipeline for ${n}`,layout:"auto",vertex:{module:l,entryPoint:"vs"},fragment:{module:l,entryPoint:"fs",targets:[{format:r.format}]}}));const p=s[c];for(let t=1;t<r.mipLevelCount;++t)for(let o=0;o<r.depthOrArrayLayers;++o){i[0]=o,e.queue.writeBuffer(u,0,i);const s=e.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:a},{binding:1,resource:r.createView({dimension:n,baseMipLevel:t-1,mipLevelCount:1})},{binding:2,resource:{buffer:u}}]}),f={label:"mip gen renderPass",colorAttachments:[{view:r.createView({dimension:"2d",baseMipLevel:t,mipLevelCount:1,baseArrayLayer:o,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},l=e.createCommandEncoder({label:"mip gen encoder"}),c=l.beginRenderPass(f);c.setPipeline(p),c.setBindGroup(0,s),c.draw(3),c.end();const d=l.finish();e.queue.submit([d])}}window.MIPMAP=r})();